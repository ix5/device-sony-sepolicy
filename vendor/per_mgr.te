# Policy for pm-service and pm-proxy
type per_mgr, domain;
type per_mgr_exec, exec_type, vendor_file_type, file_type;

init_daemon_domain(per_mgr);

# avc: granted { add } for service=vendor.qcom.PeripheralManager pid=606 uid=1000 scontext=u:r:per_mgr:s0 tcontext=u:object_r:per_mgr_service:s0 tclass=service_manager
# avc: granted { find } for service=vendor.qcom.PeripheralManager pid=662 uid=1000 scontext=u:r:per_proxy:s0 tcontext=u:object_r:per_mgr_service:s0 tclass=service_manager
add_service(per_mgr, per_mgr_service)

# TODO(b/vndswitch): Remove once per_mgr uses vendor binder and
# per_mgr_service is a vndservice_manager_type
typeattribute per_mgr binder_in_vendor_violators;

# TODO(b/vndswitch): Enable once per_proxy uses vendor binder
#vndbinder_use(per_mgr)

# avc: denied { call } for comm="pm-service" scontext=u:r:per_mgr:s0 tcontext=u:r:servicemanager:s0 tclass=binder
# avc: denied { transfer } for comm="pm-service" scontext=u:r:per_mgr:s0 tcontext=u:r:servicemanager:s0 tclass=binder
# avc: denied { search } for name="593" dev="proc" ino=20029 scontext=u:r:servicemanager:s0 tcontext=u:r:per_mgr:s0 tclass=dir
# avc: denied { read } for comm="servicemanager" name="current" dev="proc" ino=19387 scontext=u:r:servicemanager:s0 tcontext=u:r:per_mgr:s0 tclass=file
# TODO(b/vndswitch): Remove once per_proxy uses vendor binder
binder_use(per_mgr)

binder_call(per_mgr, hal_gnss)
binder_call(per_mgr, per_proxy)
binder_call(per_mgr, rild)
binder_call(per_mgr, wcnss_service)

# FIXED: Which denial/specific service?
# -> was a labeling issue for vendor.qcom.PeripheralManager, fixed now
#allow per_mgr default_android_service:service_manager find;
#userdebug_or_eng(`
#  auditallow per_mgr default_android_service:service_manager find;
#')

allow per_mgr self:capability net_bind_service;

allow per_mgr self:socket create_socket_perms;
allowxperm per_mgr self:socket ioctl msm_sock_ipc_ioctls;
allow per_mgr ssr_device:chr_file { open read };

r_dir_file(per_mgr, sysfs_msm_subsys)
# avc: denied { search } for comm="pm-service" name="msm_subsys" dev="sysfs" ino=17766 scontext=u:r:per_mgr:s0 tcontext=u:object_r:sysfs_msm_subsys:s0 tclass=dir
# avc: denied { open } for comm="pm-service" path="/sys/bus/msm_subsys/devices" dev="sysfs" ino=17768 scontext=u:r:per_mgr:s0 tcontext=u:object_r:sysfs_msm_subsys:s0 tclass=dir
# TODO: Confirm this works on all platforms
# (at least tama doesn't have /sys/bus/* in platform contexts)
# /sys/bus/esoc/devices is now sysfs_esoc
allow per_mgr sysfs_esoc:dir { read open };
# This is too broad, but test on tama etc:
#allow per_mgr sysfs:file { read open };
#userdebug_or_eng(`
#  auditallow per_mgr sysfs:file { read open };
#')

# Set the peripheral state property (seems unused on tone)
#set_prop(per_mgr, per_mgr_state_prop);

# avc: granted { search } for comm="pm-service" name="/" dev="tmpfs" ino=13798 scontext=u:r:per_mgr:s0 tcontext=u:object_r:device:s0 tclass=dir
allow per_mgr device:dir search;
# Everything apart from {search} should be safe to remove
#allow per_mgr device:file { create write open };
#userdebug_or_eng(`
#  auditallow per_mgr device:dir search;
#  auditallow per_mgr device:file { create write open };
#')

# avc: denied { module_request } for comm="pm-service" kmod="net-pf-42" scontext=u:r:per_mgr:s0 tcontext=u:r:kernel:s0 tclass=system
# Follow crosshatch sepolicy and ignore:
dontaudit per_mgr kernel:system module_request;
