type qcrilam, domain;
# TODO: coredomain for coredomain_hwservice?
#type qcrilam, domain, coredomain;
# All core domains (as opposed to vendor/device-specific domains)
#attribute coredomain;

# TODO: Is this necessary?
typeattribute qcrilam binder_in_vendor_violators;

# TODO(b/vndbinder): Switch to vndbinder
#vndbinder_use(qcrilam)

# TODO: Check if we need system or app domain
#app_domain(qcrilam)

#allow qcrilam { app_api_service }:service_manager find;

# TODO: FIXME: IMPORTANT
# ??????????????????????????
# ??????????????????????????
# ContextImpl: Calling a method in the system process without a qualified user: android.app.ContextImpl.startService:1531 android.content.ContextWrapper.startService:664 android.content.ContextWrapper.startService:664 com.sony.qcrilam.BootReceiver.onReceive:21 android.app.ActivityThread.handleReceiver:3417
# avc: granted { transfer } for comm="om.sony.qcrilam" scontext=u:r:system_app:s0 tcontext=u:r:rild:s0 tclass=binder

# TODO: Don't set group etc in QcRilAm apk?
# E SELinux : selinux_android_setcontext:  Error setting context for app with uid 1000, seinfo platform:privapp:targetSdkVersion=28:complete: Permission denied
# F zygote64: jni_internal.cc:616] JNI FatalError called: (com.sony.timekeep) frameworks/base/core/jni/com_android_internal_os_Zygote.cpp:750: selinux_android_setcontext(1000, 0, "platform:privapp:targetSdkVersion=28:complete", "com.sony.timekeep") failed

# avc: granted { call } for comm="om.sony.qcrilam" scontext=u:r:platform_app:s0:c512,c768 tcontext=u:r:rild:s0 tclass=binder
# avc: granted { call } for scontext=u:r:platform_app:s0:c512,c768 tcontext=u:r:rild:s0 tclass=binder
# avc: granted { call } for comm="om.sony.qcrilam" scontext=u:r:platform_app:s0:c512,c768 tcontext=u:r:rild:s0 tclass=binder
# avc: granted { transfer } for comm="om.sony.qcrilam" scontext=u:r:platform_app:s0:c512,c768 tcontext=u:r:rild:s0 tclass=binder
# avc: granted { call } for scontext=u:r:platform_app:s0:c512,c768 tcontext=u:r:rild:s0 tclass=binder
# avc: granted { transfer } for scontext=u:r:platform_app:s0:c512,c768 tcontext=u:r:rild:s0 tclass=binder

#
vndbinder_use(qcrilam)
allow qcrilam_service self:service_manager add;
auditallow qcrilam_service self:service_manager add;
allow qcrilam_service hal_telephony_hwservice:hwservice_manager find;
auditallow qcrilam_service hal_telephony_hwservice:hwservice_manager find;
binder_call(qcrilam_service, hal_telephony_server)
binder_call(hal_telephony_server, qcrilam_service)
binder_call(vnd_qcril_audio_hwservice, hal_telephony_server)
binder_call(hal_telephony_server, vnd_qcril_audio_hwservice)
#

#add_service(qcrilam, qcrilam_service)
#auditallow qcrilam qcrilam_service:service_manager { add find };
allow qcrilam qcrilam_service:service_manager find;
auditallow qcrilam qcrilam_service:service_manager find;
# TODO: Which one?
#add_hwservice(qcrilam, qcrilam_service)
#auditallow qcrilam qcrilam_service:hwservice_manager { add find };

typeattribute qcrilam binder_in_vendor_violators;

binder_use(qcrilam)
auditallow qcrilam servicemanager:binder { call transfer };
allow servicemanager qcrilam:dir search;
allow servicemanager qcrilam:file { read open };
allow servicemanager qcrilam:process getattr;
binder_use(qcrilam_service)
auditallow qcrilam_service servicemanager:binder { call transfer };
allow servicemanager qcrilam_service:dir search;
allow servicemanager qcrilam_service:file { read open };
allow servicemanager qcrilam_service:process getattr;

hwbinder_use(qcrilam)
auditallow qcrilam hwservicemanager:binder { call transfer };
auditallow hwservicemanager qcrilam:binder { call transfer };

#attribute untrusted_app_visible_hwservice;
#attribute data_between_core_and_vendor_violators;

# TODO: Is this necessary? And shouldn't it be qcrilam_service?
#allow qcrilam vnd_qcril_audio_hwservice:hwservice_manager { find };
#auditallow qcrilam vnd_qcril_audio_hwservice:hwservice_manager { find };
# Can't use { add } because of neverallow from rild!
# > add_hwservice(rild, vnd_qcril_audio_hwservice)
# gets converted to:
# -> neverallow { domain -rild } vnd_qcril_audio_hwservice:hwservice_manager add;
# OR: leave rild only with { find } perms and add hwserver via qcrilam:
#add_hwservice(qcrilam, vnd_qcril_audio_hwservice)
allow qcrilam_service vnd_qcril_audio_hwservice:hwservice_manager { find };
auditallow qcrilam_service vnd_qcril_audio_hwservice:hwservice_manager { find };
#auditallow qcrilam vnd_qcril_audio_hwservice:hwservice_manager { find add };
#allow qcrilam_service vnd_qcril_audio_hwservice:hwservice_manager { find add };
# TODO: Remove me. try with regular service_manager?
#allow qcrilam vnd_qcril_audio_hwservice:service_manager { find add };
#allow qcrilam_service vnd_qcril_audio_hwservice:service_manager { find add };
#allow qcrilam app_api_service:service_manager { find add };
#allow qcrilam_service app_api_service:service_manager { find add };

# from marlin
#allow qcrilam cgroup:file w_file_perms;

# TODO: Is this necessary?
binder_call(qcrilam, vnd_qcril_audio_hwservice)
auditallow qcrilam vnd_qcril_audio_hwservice:binder { call transfer };

# Instead of binder_call(platform_app, rild)
binder_call(qcrilam, rild)
auditallow qcrilam rild:binder { call transfer };

# Instead of binder_call(platform_app, per_mgr)
# TODO: Is this necessary?
binder_call(qcrilam, per_mgr)
auditallow qcrilam per_mgr:binder { call transfer };
